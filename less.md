## Javascript 基础笔记
---
### 基本数据类型的坑
	- NaN 也是一个数字，用typeof会返回'number'
	- null 用来表示一个空对象，用typeof会返回'object'
	- typeof 返回数据类型的字符串表达
***
### 数据类型的转换
#### 转为String
- __obj.toString()__:不影响原变量，null和undefined值没有该方法
- __String(obj)__(函数):对于Number和Boolean类型来说就是调用了toString()方法
#### 转为Number
- __Number(obj)__(函数):遇到含有非数字内容、undefined转为NaN，空字符串、null转为0
- __parseInt(obj)__:可取出字符串中有效整数内容 
- __parseFloat(obj)__:可取出字符串中有效浮点数内容，这两个函数如果遇到非字符串会先转为字符串然后操作
#### 转为Boolean
- __Boolean(obj)__:数字转布尔，除0、NaN外都是true; 字符串转布尔，除了空字符串外都是true; null和undefined转布尔都是false;
***
### 运算符
#### 算数运算符
- 对非Number类型的值进行运算时，会将这些值转换为Number再进行运算（除了字符串加法）。
- 任何值和NaN做运算都得NaN。
- 对两个字符串加法即字符串拼接，任何值和字符串做加法都会先转为字符串然后再拼接。
- 任何值做-*/会自动转换成Number，可利用-0，*1，/1转换为Number
- __负号__ 会把非Number值转为Number值再运算
- __正号__ 可把一个其他数据类型转为Number
- __自增__:a++和++a都会使原变量的值自增1，但a++和++a表达式的值不同，a++的值等于原变量的值（自增前）++a的值等于原变量的新值（自增后）

#### 逻辑运算符
- __取反__:可利用两次取反将其他数据类型转为布尔值
- __或__ :JS中的或属于短路的或（第一个值为true则不会检查第二个值）
- 非布尔值的逻辑运算，会先将其转换为布尔值进行运算并返回原值。__与__ 运算中，如果两个值都为true则返回后面的值；如果两个值中有false,则返回靠前的false。(如果第一个值为true则必然返回第二个值，如果第一个值为false则直接返回第一个值)

#### 关系运算符
- 对于非数值进行比较时，会将其转换为数字然后再比较
- 任何值和NaN做任何比较，都是false
- 如果比较符号两边都是字符串，会逐位（两位一样则比较下一位）比较字符串的Unicode编码

#### 相等运算符
- ==比较两个不同类型的值时会自动转换类型。（基本转成数字）
- ```null==0 //false ; undefined==null//true```
- NaN不和任何值相等，包括它本身
***
### 语句
- break用来退出switch或循环语句。（不用于if语句）
- break只能退出离它最近的循环。如果想结束远层循环，需要用label标识当前循环，然后用break跟着label结束指定循环。如:
```
hello:
	for(){
		for(){
			if(){
				break hello;
			}
		}
	}
```
- break和continue的区别:break用来结束当前循环，continue用来跳过当前循环。
- 三元表达式在使用过程中不能使用break,continue等语句，否则会报错。
***
### 对象
#### 对象的分类
- __内建对象__:由ES标准定义的对象，在任何ES的实现中都可以使用。
- __宿主对象__:由JS运行环境提供的对象，主要指浏览器提供的对象。
- __自定义对象__:由开发人员自己创建的对象。 

#### 对象的基本操作
- __创建对象__:
	1. 使用构造函数:`var obj = new Object();`
	2. 使用对象字面量:`var obj = {属性名:属性值，属性名:属性值};` 对象字面量的属性名引号可加可不加
	3. 使用工厂方法创建对象
- __添加/修改属性__:对象.属性名=属性值;
- __读取属性__:对象.属性名；
- __删除属性__:delete 对象.属性名; 

#### 对象属性
- 特殊属性名需要用:对象[“属性名”]=属性值 的方式，在[]中可以直接传递变量名，调用该属性时会读取变量，便于修改。
- 对象的属性值可以是任意数据类型，甚至可以是一个对象。
- in运算符: 检查一个对象中是否有指定属性，有则返回true，无返回false  语法:属性名 in 对象名
- 基本数据类型的值在栈中存储，各值独立存在，修改一个不影响其他
- 引用数据类型（对象）的值保存在堆内存，变量保存的是对象的引用，两个变量名如果保存同一个对象引用，修改一个另一个会受到影响。比较两个引用数据类型时比较的是对象的内存地址。

#### 对象方法
- 当函数作为对象的属性，称其为该对象的方法 。
- 使用for in语句枚举对象中的属性:
```
	for( var 变量名 in 对象){
		//对象有几个属性，循环体就执行几次，变量名就是属性的名字
	}
```
***
### 函数
#### 创建函数:
- 使用构造函数:`var fun = new Function();` //一般不用
- 使用函数声明:```function 函数名（[形参1，形参2，形参3...形参N]）{函数体}```
- 使用函数表达式:```var 函数名 = function（[形参1，形参2，形参3...形参N]）{函数体};```
- 多余实参不会被赋值。如果实参的数量少于形参的数量，无对应实参的形参将是undefined，实参可以是对象或函数
- __立即执行函数__:该函数定义完立即被调用，只会执行一次。
```
(function(){
	函数体
})([参数]);
```
#### 作用域:全局作用域和函数作用域
- __全局作用域__:直接编写在script标签中的JS代码都在全局作用域中。在页面打开时创建，在页面关闭时销毁。在全局作用域中有一个全局对象window可直接使用。在全局作用域中创建的对象都会作为window对象的属性保存，创建的函数都会作为window对象的方法保存。
- __变量的声明提升__:var声明的变量会在所有代码执行前被声明，不用var关键字则不会被声明提升。
- __函数声明提升__ :使用函数声明形式创建的函数会在所有代码执行前被创建，但函数表达式不行。
- __函数作用域__:调用函数时创建，在函数执行完毕后销毁。函数作用域中可以访问到全局作用域的变量，反之不行。在函数中不使用var声明的变量都会成为全局变量。

#### **this(需要背):** 
解析器（浏览器）每次调用函数时，都会向函数内部传递进一个隐含的参数，这个隐含的参数就是this。this指向的是一个对象，我们称为函数执行上下文对象。根据函数调用方式的不同，this会指向不同的对象。
- 以函数的形式调用时，this永远都是window
- 以方法的形式调用时，this就是调用方法的那个对象
- 以构造函数的形式调用时，this就是新创建的那个对象
- 在事件的响应函数中，响应函数是给谁绑定的，this就是谁
任何函数本质上都是通过某个对象来调用的，如果没有直接指定就是window；所有函数内部都有一个变量this，它的值是调用函数的当前对象。

#### 构造函数
- 构造函数习惯上首字母大写。与普通函数不同，构造函数需要使用new 关键字调用。
- 构造函数的执行流程:
  1. 立刻创建一个新的对象
  2. 将新建的对象设置为函数中的this, 在构造函数中可以使用this来引用新建的对象 
  3. 逐行执行函数中的代码
  4. 将新建的对象作为返回值返回
- 使用工厂方法创建的对象，使用的构造函数都是Object，所以创建的对象都是Object类型的，导致无法区分出多数不同类型的对象。
- 使用同一个构造函数创建的对象称为一类对象，所以也将一个构造函数称为一个类。将通过一个构造函数创建的对象，称为该类的实例。

#### 原型
- 我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype, 这个属性对应着一个对象，这个对象就是我们所谓的原型对象。
- 当函数以构造函数的形式调用时，它所创建的对象中都会有一个隐含的属性，指向该构造函数的原型对象，我们可以通过__proto__来访问该属性。
- 原型对象就相当于一个公共的区域，所有同一个类的实例都能访问到这个原型对象。我们可以将对象中共有的内容统一设置到原型对象中。
- 当我们访问一个对象的属性或方法时，它会先在对象自身中寻找，如果没有则会去原型对象中寻找，如果原型对象中没有，则去原型的原型中寻找，直到找到Object对象的原型（Object对象的原型无原型）【原型链】。 
- 所以，创建构造函数时，可以将这些对象共有的属性和方法统一添加到构造函数的原型对象中。 
- 可以使用hasOwnProperty()来检查对象自身中是否含有该属性。
- 直接在页面中打印一个对象时，输出的是对象的toString()方法的返回值。
***
### 垃圾:
一个对象没有任何的变量或属性对它进行引用，JS会自动垃圾回收。但是这种对象赋值给一个变量之后不会被自动回收，需要我们将不再使用的对象设置为null即可。
***
### 内建对象:
#### 数组:
与普通对象不同，普通对象用字符串作为属性名，数组则使用数字来作为索引操作元素值（属性）。
- 创建数组对象:
  1. 使用构造函数 ```var arr = new Array( );```
  2. 使用数组字面量 ```var arr = []; (可在创建时就指定数组中元素)```
- 向数组中添加元素:
```数组[索引]=值```
- 读取数组元素:
```数组[索引]（读取不存在的索引会返回undefined```
- 获取数组长度:length属性
```数组.length```
length可修改，修改后大于原长度，多出部分会空出来，小于原长度，多出部分会被删除。可利用length向数组最后一位添加元素
- 数组的方法:
```push/pop/unshift/shift...```
***
### 包装类
在JS中提供了三个包装类（String(),Number(),Boolean()），可以将基本数据类型转换为对象，但实际开发中不会使用基本数据类型对象。只有对基本数据类型调用属性和方法时，浏览器才会暂时使用包装类将其转换为对象，然后再调用对象的属性和方法。
***
### 正则表达式
#### 创建正则表达式对象:
```
var 变量 = new RegExp(“正则表达式”，“匹配模式”); 如var res = new RegExp("a","I");//查看字符串是否含有a，忽略大小写。
```
- 使用字面量创建正则表达式:
```var 变量 = /正则表达式/匹配模式 （g为全局搜索模式）```
- [a-z]任意小写字母； [A-Z] 任意大写字母； [A-z]任意字母；[0-9]任意数字
- [^] 除了……以外 
#### 字符串和正则相关的方法:
- __search()__ 可以搜索字符串中是否含有指定内容，有则返回第一次出现索引，无则返回-1。
- __match()__ 可以根据正则表达式从一个字符串中将符合条件的内容提取出来（封装到数组形式返回）。 
- __replace()__ 将字符串中指定内容换为新内容，需要两个参数，1是被替换的内容（可接收一个正则表达式 ），2是新的内容，默认只替换第一个
- __split()__ 可传入一个正则表达式作为参数，按照正则表达式拆分字符串
#### 正则表达式语法
- 量词:设置一个内容出现的次数，只对它前边一位的内容起作用。
``` 
{n} 正好出现N次，如/a{3}/
{m,n} 出现m-n次
{m,} m次以上
+ 至少一个， =={1,}
* 0或多个，=={0,}
？0或1个， =={0,1}
^ 匹配开头
$ 匹配结尾 
. 表示任意字符
\ 转义字符 （注意:如果使用构造函数，由于其参数是一个字符串，\是字符串中的转义字符，如果要使用\必须使用\\来代替 ）
\w 任意字母、数字、下划线
\W 除了字母、数字、下划线
\d 任意数字
\D 除了数字
\s 空格
\S 除了空格
\b 单词边界
\B 除了单词边界
匹配开头空格/^\s*/
匹配结尾空格 /\s*$/
匹配开头和结尾的空格/^\s*|\s*$/g
```
***
### DOM(宿主对象)
- 四种常见的节点:
  1. 文档节点:整个HTML文档
  2. 元素节点:HTML标签
  3. 文本节点:HTML标签中的文本内容
  4. 属性节点:元素的属性
- 节点对象的属性:
  1. nodeName
  2. nodeType
  3. nodeValue
#### DOM 查询
- __innerHTML__:用于获取元素内部HTML代码，用于自结束标签无意义
- 读取元素节点的属性，直接使用 ```元素.属性名 （class属性不行，需要用className)```
- 获取元素节点
```
getElementByID();
getElementsByName();
getElementsByTagName();
```
- 获取元素节点的子/父节点
1. childNodes 属性:会获取包括文本节点在内的所有节点，DOM标签间的空白也会被当成文本节点
2. firstChild 属性 
3. lastChild 属性  
4. parentNode
- DOM查询剩余的方法:
  1. __获取body__:``` document.getElementsByTagName("body")[0]  // 或document.body```
  2. __HTML根标签__:```document.documentElement;```
  3. __document.all__ 代表页面中所有元素，等价于 ```document.getElementsByTagName("* ")```
  4. __getElementsByClassName()__;//IE8以下不兼容，避免使用
  5. __document.querySelector()__//需要选择器字符串作为参数，可根据一个CSS选择器来查询一个元素节点对象，使用该方法只会返回第一个符合条件的元素
  6. __document.querySelectorAll()__//可查询一个到多个，封装为数组
#### DOM增删改
- __creatElement()__:创建元素节点，参数为标签名
- __creatTextNode()__:创建文本节点，参数为文本内容字符串
- __appendChild()__:向一个父节点中添加一个新的子节点，```语法:父节点.append(子节点)```
- __removeChild()__:删除一个子节点。```语法:父节点.removeChild(子节点) // 常用: 子节点.parentNode.removeChild(子节点)```
- __replaceChild()__:使用指定子节点替换已有子节点。```语法:父节点.replaceChild(新子节点，旧子节点)```
- __insertBefore()__: 在指定子节点前插入新的子节点。```语法:父节点.insertBefore(新子节点，旧子节点);```
- 使用innerHTML也可以完成DOM的增删改的相关操作，如:```city.innerHTML += "<li>广州</li>"```，但是直接改写标签会影响原有节点绑定的事件，但可以用来添加文本节点，与其他方法结合使用。
	
#### 使用DOM操作CSS
- 通过JS修改元素的内联样式。```语法:元素.style.样式名 = 样式值;```
- 注意:如果CSS样式名中含有-，这种名称在JS中不合法，需要将该样式名修改为驼峰写法。（通过style属性设置和读取的样式都是内联样式，无法读取样式表中的样式）如果css中含有!important，则拥有最高的优先级，JS修改样式会失败
- 读取元素当前的样式(只读)。```语法:元素.currentStyle.样式名（可以用来读取当前元素正在显示的样式，只有IE支持）```如果样式没有设置会获取到默认值。在其他浏览器中可以使用:```getComputedStyle()```方法来获取当前元素正在显示的样式，需要两个参数，第一个是要获取样式的元素，第二个可以传递一个伪元素，一般是null；该方法会返回一个对象，对象中封装了当前元素对应的样式（通过.样式名访问）如果样式没有设置会获取到当前真实的值。该方法不支持IE8及以下。	
#### 其他样式操作（只读）
- ```element.clientWidth/clientHeight ```获取可见宽度/高度（包括内容区和内边距），返回值是数字
- ```element.offsetWidth/offsetHeight ```获取元素整个宽高（包括内容区、内边距和边框），返回值是数字
- ```element.offsetParent ```获取元素定位父元素，会获取到离当前元素最近的开启了定位的祖先元素
- ```element.offsetLeft/offsetTop``` 获取元素相对于其定位元素的水平/垂直偏移量
- ```element.scrollWidth/scrollHeight``` 获取子元素滚动区域的宽高
- ```element.scrollLeft/scrollTop``` 获取水平/垂直滚动条滚动的距离
- 当```scrollHeight-scrollTop = clientHeight```时，说明垂直滚动条滚动到底
- 当```scrollWidth-scrollLeft = clientWidth```时，说明水平滚动条滚动到右端（一般没用）
***
### 事件对象（Event对象）
当事件的响应函数被触发时，浏览器每次都会将一个事件对象作为实参传递进响应函数。在事件对象中封装了当前事件相关的所有信息。如:鼠标坐标。但是在IE8中，当响应函数被触发时，浏览器不会传递，因为在IE8及以下的浏览器中，是将事件对象作为window对象的属性保存的。
- 兼容写法
```if(!event){
	event = window.event;
			}
			或
	event = event || window.event;
```
- __clientX / clientY__ : 用于获取鼠标在当前可见窗口的坐标。
- __pageX / pageY__ : 用于获取鼠标相对于当前页面的坐标（IE8中不支持）
#### 事件冒泡:
- 当后代元素上的事件被触发时，其祖先元素的相同事件也会被触发
- 取消冒泡:
```
event = event || window.event;
event.cancelBubble = true;
```
#### 事件的委派:
- 将事件统一绑定给元素共同的祖先元素，当后代元素上的事件触发时，会一直冒泡到祖先元素，从而通过祖先元素的响应函数来处理事件。事件委派是利用了冒泡， 通过委派可以减少事件绑定的次数，提高程序性能。
- Event中的target表示触发事件的对象。使用``` 对象.事件 = 函数 ```的形式绑定响应函数，只能为一个元素的一个事件绑定一个响应函数，无法绑定多个，如果绑定了多个，后面的响应函数会覆盖前面的。
- 对元素的一个事件绑定多个响应函数，需要使用``` 对象.addEventListener()```参数:
  1. 事件的字符串（去掉on）
  2. 回调函数 
  3. 是否在捕获阶段触发事件，需要一个布尔值，一般都传false。（不支持IE8及以下的浏览器）
- 所以，在这些浏览器中可以使用attachEvent()来绑定事件。 attachEvent()需要的参数:
  1. 事件的字符串（需要on)
  2. 回调函数: 该方法与addEventListener()的区别是，该方法是后绑定先执行，执行顺序和addEventListener()相反。
#### 事件的传播:
- 微软认为事件应由内向外传播，先触发当前元素的事件，再向当前元素的祖先元素上传播，事件应该在冒泡阶段执行。
- 网景认为事件应该在捕获阶段执行，当事件触发时应先触发当前元素最外层的祖先元素事件，然后向内传播给后代元素。
- 如果希望在捕获阶段就触发事件，可将addEventListener()第三个参数设为true (IE8以下没有捕获阶段)
- W3C:
	1. 捕获阶段:默认此时不会触发事件
	2. 目标阶段:事件捕获到目标元素
	3. 冒泡阶段:目标元素上触发事件
#### 拖拽
- 鼠标在目标元素上按下时 			    onmousedown  (绑定目标)
- 鼠标开始移动时，被拖拽元素跟随		 onmousemove （绑定document）
- 鼠标松开时，被拖拽元素固定位置		 onmouseup	  (绑定document)
- 注意:当我们拖拽一个网页中的内容，浏览器会默认去搜索引擎中搜索内容，会导致拖拽功能的异常。可以通过在onmousedown响应函数里最后加上return false取消，但是该方法不兼容IE8。IE8需要用setCapture()和releaseCapture()避免拖拽功能的异常。setCapture()方法只有IE支持，但在火狐中调用时不会报错，所以需要套一层判断或使用逻辑与运算。
#### 滚轮事件 
- __onmousewheel__ 为鼠标滚轮滚动的事件，会在滚轮滚动时触发，但是火狐浏览器不支持该属性，在火狐中需要使用
- __DOMMouseScroll__ 来绑定滚动事件，该事件需要通过addEventListener()函数绑定。
##### 判断鼠标滚轮滚动的方向:
- __event.wheelDelta__ 向上滚动是120，向下滚动是-120，不看大小只看正负，但火狐中不支持，需要用event.detail，向上滚动是-3，向下滚动是3。
- 注意:当滚轮滚动时，如果浏览器有滚动条，滚动条会随之滚动，这是浏览器的默认行为，如果不希望发生，则可以return false取消默认行为。
- 使用addEventListener()方法绑定响应函数取消默认行为不能使用return false，需要使用event.preventDefault()取消默认行为，但是IE8不支持;
#### 键盘事件
- 键盘事件一般会绑定给一些可以获取到焦点的对象或者是document。
  1. 某个键被按下onkeydown，如果一直按着某个按键，则事件会一直被触发。
  2. 某个键被松开onkeyup
  3. ketCode可以获取按键编码，可以用来判断哪个按键被按下。
- 除了keyCode，事件对象中还提供了几个属性:
```
altKey
controlKey
shiftKey

用来判断alt/control/shift是否被按下，如果被按下返回true，否则返回false
```
***
### BOM对象:
包括Window,Navigator,Location,History,Screen。像Navigator,Location,History这些对象在浏览器中都是作为Window对象的属性保存的。
##### __Window对象__:
代表整个浏览器的窗口，也是网页中的全局对象 
##### __Navigator对象__:
代表当前浏览器的信息，通过该对象可以识别不同的浏览器。一般只会使用userAgent属性判断浏览器信息:它是一个字符串，包含有用来描述浏览器信息的内容。
##### __Location对象__:
代表当前浏览器的地址栏信息，可以操作实现页面跳转。该对象中封装了浏览器的地址栏信息，直接打印location会获取到当前页面的完整路径。
- 方法:
	1. __assign()__:用来跳转到其他页面，会生成历史记录
	2. __reload()__:重新加载当前页面，如果参数传入true则会强制清空缓存
	3. __replace()__:用新页面替换当前页面，不会生成历史记录，不能使回退按钮回退 
##### __History对象__:
代表浏览器的历史记录，只能操作浏览器前后翻页。
- History对象常用方法:
	1. back()
	2. forward()
	3. go()//需要一个整数作为参数（例如:1表示向前跳转一个页面，-1表示向后跳转一个页面）
##### __Screen对象__:
代表用户的屏幕信息，获取到用户显示器的相关信息
***
### 延时调用和定时调用
#### 二十五、定时调用
- （window对象的四个方法之:setInterval/clearInterval）
- 如果希望一段程序，可以每间隔一段时间调用一次，需要使用定时调用
- __setInterval__:可以将一个函数每间隔一段时间执行一次（执行多次）。参数:
	1. 回调函数，该函数会每间隔一段时间被调用一次
	2. 间隔的时间，单位是毫秒 
	3. 返回值:一个Number类型的数据，作为定时器的唯一标识 
- __clearInterval__:用来关闭一个定时器。参数:一个定时器标识
- 注意:在开启定时器之前，需要把当前元素上其他的定时器关闭。

#### 延时调用
- （window对象的四个方法之:setTimeout/clearTimeout）
- __setTimeout__:函数隔一段规定的时间后再调用，且只执行一次。参数:
	1. 回调函数，该函数会隔一段规定的时间后再调用
	2. 隔的时间，单位是毫秒 
	3. 返回值:一个Number类型的数据，作为延时调用的唯一标识 
- __clearTimeout__:用来关闭一个延时调用。参数:一个延时调用标识
- 延时调用和定时调用是可以互相代替的。
***
#### 二十七、类的操作
- 通过style属性修改元素的样式，每修改一次，浏览器就要重新渲染一次页面，执行性能比较差。可以通过修改元素class属性来间接修改样式。
```
obj.className += " new name";
```
***
### JSON
- JSON就是一个特殊格式的字符串，可以被任意语言识别，并且可以转换为任意语言中的对象，来用作数据交互。
- JSON:JavaScript Object Notation JS对象表示法
- JSON和JS对象格式一样，只是JSON字符串中属性名必须加双引号。
- JSON分类
	- 对象{}
	- 数组[]
- JSON中允许的值:
	- 字符串
	- 数值
	- 布尔值
	- 数组
	- 普通对象（不包含函数）
	- null
##### 将JSON字符串转换为JS中的对象:
- JS中有一个工具类，就叫JSON（IE7及以下不支持），可以实现JS对象和JSON的相互转换。
- __JSON.parse()__:将JSON字符串转换为JS对象，需要一个JSON字符串作为参数，会将该字符串转为JS对象并返回。
- __JSON.stringify()__:将JS对象转换为JSON，需要一个JS对象作为参数，会将该对象转为JSON并返回。
- eval()函数可以执行一段字符串形式的JS代码，并将执行结果返回。注意:如果使用它执行的字符串中含有{},eval()会把{}看作代码块，如果不希望被当作代码块解析，需要在{}前后加()。该函数执行性能差，且存在安全隐患。在需要兼容IE7时，不推荐使用该函数，只需要引入一个外部JS文件处理即可。